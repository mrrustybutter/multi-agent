#!/usr/bin/env tsx

/**
 * Orchestrator - The brain of the multi-agent system
 * Connects to all MCP servers and coordinates actions
 */

import { EventEmitter } from 'eventemitter3';
import PQueue from 'p-queue';
import path from 'path';
import { getLogger, getAgentLogger } from '@rusty-butter/logger';
import { CallToolResultSchema } from '@modelcontextprotocol/sdk/types.js';
import { 
  connectToMultipleMCPServers, 
  MCPServerConfig,
  MCPConnection,
  disconnectAll
} from '@rusty-butter/shared/mcp-connection';
import {
  QueueManager,
  QueueMessage
} from '@rusty-butter/shared/queue-manager';

// Logger
const logger = getLogger('orchestrator');
const agentLogger = getAgentLogger('orchestrator');

// Types
interface OrchestratorConfig {
  queueDir: string;
  mcpServers: MCPServerConfig[];
  maxConcurrentActions: number;
  priorityWeights: {
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
}

interface ActionResult {
  success: boolean;
  messageId: string;
  duration: number;
  error?: Error;
}

// Configuration
const config: OrchestratorConfig = {
  queueDir: process.env.QUEUE_DIR || path.join(process.cwd(), 'queues'),
  mcpServers: [
    {
      name: 'semantic-memory',
      command: 'npx',
      args: ['-y', '@modelcontextprotocol/server-memory']
    },
    {
      name: 'rustybutter-avatar',
      command: 'node',
      args: ['../packages/rustybutter-avatar/packages/mcp-server/dist/index.js']
    },
    {
      name: 'elevenlabs',
      command: 'node',
      args: ['../packages/elevenlabs-streaming/packages/mcp-server/dist/index.js'],
      env: {
        ELEVEN_API_KEY: process.env.ELEVEN_API_KEY || ''
      }
    },
    {
      name: 'twitch-monitor',
      command: 'tsx',
      args: ['../monitors/twitch-monitor/src/index.ts']
    },
    {
      name: 'discord-monitor',
      command: 'tsx',
      args: ['../monitors/discord-monitor/src/index.ts'],
      env: {
        DISCORD_TOKEN: process.env.DISCORD_TOKEN || ''
      }
    },
    {
      name: 'event-monitor',
      command: 'tsx',
      args: ['../monitors/event-monitor/src/index.ts']
    },
    {
      name: 'social-monitor',
      command: 'tsx',
      args: ['../monitors/social-monitor/src/index.ts'],
      env: {
        X_API_KEY: process.env.X_API_KEY || '',
        X_API_SECRET_KEY: process.env.X_API_SECRET_KEY || '',
        X_ACCESS_TOKEN: process.env.X_ACCESS_TOKEN || '',
        X_ACCESS_TOKEN_SECRET: process.env.X_ACCESS_TOKEN_SECRET || '',
        X_BEARER_TOKEN: process.env.X_BEARER_TOKEN || '',
        REDDIT_CLIENT_ID: process.env.REDDIT_CLIENT_ID || '',
        REDDIT_CLIENT_SECRET: process.env.REDDIT_CLIENT_SECRET || '',
        REDDIT_USERNAME: process.env.REDDIT_USERNAME || '',
        REDDIT_PASSWORD: process.env.REDDIT_PASSWORD || ''
      }
    }
  ],
  maxConcurrentActions: 3,
  priorityWeights: {
    critical: 1000,
    high: 100,
    medium: 10,
    low: 1
  }
};

class Orchestrator extends EventEmitter {
  private mcpConnections: Map<string, MCPConnection> = new Map();
  private queueManager: QueueManager;
  private actionQueue: PQueue;
  private isRunning: boolean = false;
  private processedMessages: Set<string> = new Set();

  constructor() {
    super();
    this.queueManager = new QueueManager(config.queueDir);
    this.actionQueue = new PQueue({ 
      concurrency: config.maxConcurrentActions 
    });
  }

  async initialize(): Promise<void> {
    logger.info('Initializing orchestrator...');

    // Connect to all MCP servers
    logger.info('Connecting to MCP servers...');
    this.mcpConnections = await connectToMultipleMCPServers(config.mcpServers);
    logger.info(`Connected to ${this.mcpConnections.size} MCP servers`);

    // Initialize queue manager
    await this.queueManager.initialize();
    this.queueManager.on('message', this.handleQueueMessage.bind(this));

    // Start processing loop
    this.isRunning = true;
    this.startProcessingLoop();

    logger.info('Orchestrator initialized successfully');
  }

  private async handleQueueMessage(message: QueueMessage): Promise<void> {
    // Skip if already processed
    if (this.processedMessages.has(message.id)) {
      return;
    }

    logger.info(`New queue message: ${message.id} from ${message.source}`);
    
    // Calculate priority score
    const priorityScore = this.calculatePriorityScore(message);
    
    // Add to action queue with priority
    this.actionQueue.add(
      () => this.processAction(message),
      { priority: priorityScore }
    );
  }

  private calculatePriorityScore(message: QueueMessage): number {
    const baseScore = config.priorityWeights[message.priority];
    
    // Add time-based decay (older messages get slight boost)
    const ageMinutes = (Date.now() - new Date(message.timestamp).getTime()) / 60000;
    const ageBoost = Math.min(ageMinutes * 0.1, 10);
    
    return baseScore + ageBoost;
  }

  private async processAction(message: QueueMessage): Promise<void> {
    const taskId = `action-${message.id}`;
    agentLogger.taskStarted(taskId, `Process ${message.action.type} from ${message.source}`);
    const startTime = Date.now();

    try {
      // Mark as processed
      this.processedMessages.add(message.id);

      // Route based on action type
      switch (message.action.type) {
        case 'speak':
          await this.handleSpeakAction(message);
          break;
        
        case 'avatar':
          await this.handleAvatarAction(message);
          break;
        
        case 'memory':
          await this.handleMemoryAction(message);
          break;
        
        case 'respond':
          await this.handleRespondAction(message);
          break;
        
        case 'execute':
          await this.handleExecuteAction(message);
          break;
        
        case 'search_social':
        case 'post_social':
        case 'get_mentions':
        case 'get_trending':
        case 'monitor_keywords':
        case 'get_social_status':
          await this.handleSocialAction(message);
          break;
        
        default:
          logger.warn(`Unknown action type: ${message.action.type}`);
      }

      // Clean up processed message
      await this.queueManager.deleteMessage(message.id);
      
      const duration = Date.now() - startTime;
      agentLogger.taskCompleted(taskId, duration);
      
      this.emit('action-completed', {
        success: true,
        messageId: message.id,
        duration
      } as ActionResult);

    } catch (error) {
      logger.error(`Failed to process action ${message.id}:`, error);
      agentLogger.taskFailed(taskId, error as Error);
      
      this.emit('action-failed', {
        success: false,
        messageId: message.id,
        duration: Date.now() - startTime,
        error: error as Error
      } as ActionResult);
    }
  }

  private async handleSpeakAction(message: QueueMessage): Promise<void> {
    const elevenLabs = this.mcpConnections.get('elevenlabs');
    const avatar = this.mcpConnections.get('rustybutter-avatar');
    
    if (!elevenLabs) {
      throw new Error('ElevenLabs MCP not connected');
    }

    // Set avatar expression if specified
    if (avatar && message.action.data?.expression) {
      await avatar.client.request({
        method: 'tools/call',
        params: {
          name: 'setAvatarExpression',
          arguments: {
            name: message.action.data.expression
          }
        }
      }, CallToolResultSchema);
    }

    // Generate audio
    await elevenLabs.client.request({
      method: 'tools/call',
      params: {
        name: 'generate_audio',
        arguments: {
          text: message.action.content,
          voice_id: message.action.data?.voiceId || 'Au8OOcCmvsCaQpmULvvQ',
          play_audio: true
        }
      }
    }, CallToolResultSchema);
  }

  private async handleAvatarAction(message: QueueMessage): Promise<void> {
    const avatar = this.mcpConnections.get('rustybutter-avatar');
    if (!avatar) {
      throw new Error('Avatar MCP not connected');
    }

    await avatar.client.request({
      method: 'tools/call',
      params: {
        name: message.action.data?.batch ? 'setBatchExpressions' : 'setAvatarExpression',
        arguments: message.action.data
      }
    }, CallToolResultSchema);
  }

  private async handleMemoryAction(message: QueueMessage): Promise<void> {
    const memory = this.mcpConnections.get('semantic-memory');
    if (!memory) {
      throw new Error('Semantic memory MCP not connected');
    }

    const { operation, ...args } = message.action.data;
    
    await memory.client.request({
      method: 'tools/call',
      params: {
        name: operation,
        arguments: args
      }
    }, CallToolResultSchema);
  }

  private async handleRespondAction(message: QueueMessage): Promise<void> {
    // Determine which monitor to use based on source
    const monitorMap: Record<string, string> = {
      'twitch-chat': 'twitch-monitor',
      'discord': 'discord-monitor',
      'event': 'event-monitor'
    };

    const monitorName = monitorMap[message.source];
    const monitor = this.mcpConnections.get(monitorName);
    
    if (!monitor) {
      throw new Error(`Monitor ${monitorName} not connected`);
    }

    // Send response through appropriate channel
    await monitor.client.request({
      method: 'tools/call',
      params: {
        name: 'send_message',
        arguments: {
          message: message.action.content,
          ...message.action.data
        }
      }
    }, CallToolResultSchema);
  }

  private async handleExecuteAction(message: QueueMessage): Promise<void> {
    // Execute custom action through specified MCP server
    const { server, tool, args } = message.action.data;
    const connection = this.mcpConnections.get(server);
    
    if (!connection) {
      throw new Error(`MCP server ${server} not connected`);
    }

    await connection.client.request({
      method: 'tools/call',
      params: {
        name: tool,
        arguments: args
      }
    }, CallToolResultSchema);
  }

  private async handleSocialAction(message: QueueMessage): Promise<void> {
    const socialMonitor = this.mcpConnections.get('social-monitor');
    
    if (!socialMonitor) {
      throw new Error('Social monitor MCP not connected');
    }

    // Call the appropriate social media tool
    await socialMonitor.client.request({
      method: 'tools/call',
      params: {
        name: message.action.type,
        arguments: message.action.data
      }
    }, CallToolResultSchema);
  }

  private async startProcessingLoop(): Promise<void> {
    while (this.isRunning) {
      // Clean up expired messages
      await this.queueManager.cleanExpiredMessages();
      
      // Check queue health
      const queueSize = this.actionQueue.size;
      const pending = this.actionQueue.pending;
      
      if (queueSize > 50) {
        logger.warn(`Queue backlog detected: ${queueSize} items, ${pending} processing`);
      }

      // Emit status
      this.emit('status', {
        queueSize,
        pending,
        mcpConnections: this.mcpConnections.size,
        processedTotal: this.processedMessages.size
      });

      // Wait before next check
      await new Promise(resolve => setTimeout(resolve, 5000));
    }
  }

  async shutdown(): Promise<void> {
    logger.info('Shutting down orchestrator...');
    
    this.isRunning = false;
    
    // Clear the queue
    this.actionQueue.clear();
    await this.actionQueue.onIdle();
    
    // Disconnect from MCP servers
    await disconnectAll(this.mcpConnections);
    
    // Shutdown queue manager
    await this.queueManager.shutdown();
    
    logger.info('Orchestrator shutdown complete');
  }
}

// Main startup
async function main() {
  const orchestrator = new Orchestrator();

  // Set up event handlers
  orchestrator.on('action-completed', (result: ActionResult) => {
    logger.info(`Action completed: ${result.messageId} in ${result.duration}ms`);
  });

  orchestrator.on('action-failed', (result: ActionResult) => {
    logger.error(`Action failed: ${result.messageId}`, result.error);
  });

  orchestrator.on('status', (status) => {
    logger.debug('Orchestrator status:', status);
  });

  // Initialize
  await orchestrator.initialize();

  // Handle shutdown
  process.on('SIGINT', async () => {
    logger.info('Received SIGINT, shutting down gracefully...');
    await orchestrator.shutdown();
    process.exit(0);
  });

  process.on('SIGTERM', async () => {
    logger.info('Received SIGTERM, shutting down gracefully...');
    await orchestrator.shutdown();
    process.exit(0);
  });

  logger.info('Orchestrator is running');
}

// Error handling
process.on('unhandledRejection', (error) => {
  logger.error('Unhandled rejection:', error);
  process.exit(1);
});

// Start
main().catch((error) => {
  logger.error('Failed to start orchestrator:', error);
  process.exit(1);
});